#-------------------------------------------------------------------
#
#   Filter::WrapSub - Wrap a sub with code at compile time
#
#   $Id: WrapSubs.pm,v 1.2 2007-09-28 14:22:31 erwan_lemonnier Exp $
#
#   070921 erwan Laying foundations
#

package Filter::WrapSubs;

use strict;
use warnings;
use Carp qw(croak confess);
use Data::Dumper;
use PPI;
use PPI::Find;
use PPI::Token::Word;
use Filter::Util::Call;

our $VERSION = '0.01';

use accessors ('pkg',           # name of the package processed
	       'subname',       # name of the sub currently wrapped
	       'pdom',          # the package pdom generated by PPI
	       'action',        # one of the 4 configuration strings

	       # configuration
	       'insert_top',
	       'insert_bottom',
	       'insert_before_return',
	       '_call_on_return'
	       );

#---------------------------------------------------------------
#
#   new - constructor
#

sub new {
  my ($class,$caller,$verbose) = @_;
  $class = ref $class || $class;

  croak "BUG: no caller provided" if (!defined $caller);

  my $self = bless({},$class);
  $self->pkg($caller);
  $self->{verbose} = $verbose;

  filter_add($self);

  return $self;
}

#---------------------------------------------------------------
#
#   call_on_return is special since it takes an argument list
#

sub call_on_return {
    my $self = shift;

    if (@_) {
	return $self->_call_on_return([@_]);
    }

    return @{$self->_call_on_return()};
}

#---------------------------------------------------------------
#
#   filter - edit each subroutine body
#

sub filter {
    my ($self) = @_;
    my $status;

    # check that configuration accessors are either strings or coderefs
    $self->_check_config;

    # read the whole source at once, accumulate it in $_
    do {
	$status = filter_read();
    } until ($status == 0);

    # TODO: croak here, or let Filter::Util::Call croak for us?
    croak "an error occured while filtering ".$self->pkg.": $!"
	if ($status < 0);

    # special case: empty doc
    return 0 if (length($_) == 0);

    # parse the whole source with PPI
    my $doc = PPI::Document->new(\$_) ||
	croak "failed to parse ".$self->pkg." with PPI: ".PPI::Document::errstr;

    # do not look for subs recursively: skip any anonymous sub declared within a sub.
    my $topsubs = $doc->find( sub {
	ref $_[1] ne '' && $_[1]->parent == $_[0] && $_[1]->isa('PPI::Statement::Sub');
    });

    if (ref $topsubs eq '') {
	# no subs declared in the source
	return 1;
    }

    $self->pdom($doc);

    # foreach sub declaration in the source file
    foreach my $esub (@$topsubs) {

	# find out subroutine's name
	$self->subname($self->_get_sub_name($esub));

#	print "found sub ".$self->subname."\n";

	# find the PPI block that contains the body of the subroutine
	my $subdef = $self->_get_sub_block($esub);

#	print "sub body is\n".Dumper($subdef);

	# insert code at the top of subroutine body
	my $code_top = $self->_get_code('insert_top');
	if (defined $code_top) {
	    my $brace = $subdef->start;
	    confess "BUG: expected a { for sub ".$self->subname." in package ".$self->pkg
		if ($brace->content ne "{");
	    $brace->set_content("{ ".$code_top."; ");
	}

	# insert code at the bottom of subroutine body
	my $code_bottom = $self->_get_code('insert_bottom');
	if (defined $code_bottom) {
	    my $brace = $subdef->finish;
	    confess "BUG: expected a } for sub ".$self->subname." in package ".$self->pkg
		if ($brace->content ne "}");
	    $brace->set_content($code_bottom."; }");
	}

# 	    # add code at the begining and the end of the sub
# 	    my @children = $subdef->children;

# 	    if (scalar @children == 0) {
# 		# empty sub declaration: 'sub {}'
# 		$subdef->add_element($code_top) if ($code_top);
# 		$subdef->add_element($code_bottom) if ($code_bottom);
# 	    } else {
# 		$children[0]->insert_before($code_top) if ($code_top);
# 		$children[-1]->insert_before($code_bottom) if ($code_bottom);
# 	    }
# 	}


# 	#
# 	# step 3: alter 'return' statements
# 	#
#
# 	foreach my $word (@{ $subdef->find('PPI::Token::Word') }) {
# 	    if ($word->content eq 'return') {
#
# 		# this word is 'return'
# 		my $ret_start = $word;
#
# 		do {
# 		    $word = $word->next_sibling;
# 		} until (ref $word eq '' || ($word->isa('PPI::Token::Structure') && $word->content eq ';') );
#
# 		my $ret_end = $word;
#
# 		if (ref $ret_end eq "") {
# 		    # there was no ';' after return...
# 		    $ret_start->set_content("return Sub::Contract::Pool::_validate_".$self->subname."_out()");
# 		} else {
# 		    # this word is ';' after the variables following 'return'
# 		    $ret_start->set_content("return Sub::Contract::Pool::_validate_".$self->subname."_out(");
# 		    $ret_end->set_content(");");
# 		}
# 	    }
# 	}
    }

    # serialize back the modified source tree
    $_ = $doc->serialize;

    # this feature is mostly used for testing
    if ($self->{verbose}) {
	print $_;
    }

    return 1;
}

#---------------------------------------------------------------
#
#   find out the name of the current subroutine
#

sub _get_sub_name {
    my ($self,$esub) = @_;

    # name should be the next word after 'sub'
    my @words = @{$esub->find('PPI::Token::Word')};

    confess "BUG: expected 'sub' in package ".$self->pkg
	if ($words[0]->content ne 'sub');

    my $name = $words[1]->content;

    confess "BUG: failed to parse subname in package ".$self->pkg
	if (!defined $name || $name eq "");

    return $name;
}

#---------------------------------------------------------------
#
#   find the PPI block defining the body of a sub
#

sub _get_sub_block {
    my ($self,$esub) = @_;

    my @blocks = @{ $esub->find( sub {
	ref $_[1] ne '' && $_[1]->parent == $_[0] && $_[1]->isa('PPI::Structure::Block');
    }) };

    croak "found no or more than 1 sub block for sub ".$self->subname." in package ".$self->pkg
	if (scalar @blocks != 1);

    return $blocks[0];
}

#---------------------------------------------------------------
#
#   check that the filter's configuration is valid
#

sub _check_config {
    my $self = shift;

    # TODO: check insert_top, insert_bottom, etc.

}

#---------------------------------------------------------------
#
#   return a line of code to insert in the source, or undef
#

sub _get_code {
    my ($self,$action) = @_;
    $self->action($action);

    my $code = $self->$action();
    if (ref $code eq "CODE") {
	# run code
	die;
    } else {
	return $code;
    }
}


1;

__END__

=head1 NAME

Filter::WrapSubs - Wrap subs with code before compile time

=head1 SYNOPSIS: INSERTING CODE

Let's assume you have written a small package containing two functions:

    package Small::Package;

    sub incr {
        my $a = shift;
        $a = $a + 1;
        return $a;
    }

    sub nop {
        1;
    }

Now, suppose that for some reason you want to edit this code
before compile time in order to add print statements called
upon entering and leaving every subroutine:

    sub incr { print "start!\n";
        my $a = shift;
        $a = $a + 1;
        print "end!\n"; return $a;
    print "end!\n"; }

    sub nop { print "start!\n";
        1;
    print "end!\n"; }

NOTE: We want to append the new code to already existing lines.
If we inserted new lines, the line numbers shown in error messages
would not match the source code anymore. Furthermore, if we are
to properly wrap each subroutine, we must insert code not only
at the end of the subroutine body but even before every return
statement.

For that to happen, just create the following source filter:

    package My::SourceFilter

    use Filter::WrapSubs;

    sub import {
        new Filter::WrapSubs(caller())
            ->insert_top('print "start!\n"')
            ->insert_bottom('print "end!\n"')
            ->insert_before_return('print "end!\n"');
    }

And edit your package to use your source filter:

    package Small::Package;

    use My::SourceFilter;

    sub incr {
    ...

Voila! Next time you compile Small::Package, My::SourceFilter will
tell Filter::WrapSubs to modify the source code before compile time,
and add the print lines at the beginning and end of every subroutine
body, as well as before every return statement.

=head1 SYNOPSIS: INSERTING FUNCTION CALLS

Now, suppose you want to modify incr to look like this:

    sub incr { Some::Package::check_is_integer(@_);
        my $a = shift;
        $a = $a + 1;
        return Some::Package::check_return_value($a);
    }

In other words, you want to intercept the input and return arguments
of C<incr> and do stuff with them, but with a source filter, before
compile time.

Do like above, except that your filter should look like:

    package My::SourceFilter

    use Filter::WrapSub;

    sub import {
        new Filter::WrapSubs(caller())
            ->insert_top('Some::Package::check_is_integer(@_)')
            ->call_on_return('Some::Package::check_return_value');
        );
    }

The problem with this solution is that even the subroutine C<nop>
will be modified. What we would need is a way to generate inserted
code specific to each subroutine. Read further:

=head1 SYNOPSIS: GENERATING THE INSERTED CODE

Inserting the same code within the body of all subroutines
in a filtered package doesn't take us far. We want to be able to
generate different inserted code for each subroutine and know
about the subroutine currently filtered, as well as about the
whole package source.

Filter::WrapSub offers a mechanism to do just that. Call C<new Filter::WrapSub>
with subroutine references instead of strings:

    package My::SourceFilter

    use Filter::WrapSub;

    sub import {
        new Filter::WrapSubs(caller())
            ->insert_top(\&generate_pre_code)
            ->call_on_return(\&generate_return_code);
        );
    }

    sub generate_pre_code {
	my $filter = shift;
	if ($filter->subname eq "incr") {
	    return 'Some::Package::check_is_integer(@_)';
        }
    }

    sub generate_return_code {
	my $filter = shift;
	if ($filter->subname eq "incr") {
	    return 'Some::Package::check_return_value';
        }
    }

The object C<$filter> gives you access to the filtered
package's PPI representation, so there is basically no
limitation to how complex the code generation algorithm
can be.

=head1 DESCRIPTION

Filter::WrapSubs makes it easy to write a source filter to wrap
every sub in a filtered package with tailored code, and to do
this before compile time. You may insert code at the beginning
and end of every subroutine body, before every return statement
or within every return statement. This code can be generated for
each subroutine.

If you are familiar with Hook::WrapSub or Hook::LexWrap, Filter::WrapSubs
has a similar intent. But while those C<Hook::> modules work by
replacing the wrapped sub with a closure that contains pre- and post-execution
code, Filter::WrapSubs adds the code directly in the source before
it is compiled.

To use Filter::WrapSubs you are expected to be familiar with source filters:
read C<perldoc perlfilter>.

=head1 WARNING

Filter::WrapSubs uses PPI to parse and manipulate the source of the filtered
packages. PPI is able to parse most perl code, but there are exceptions. See
PPI's documentation for examples. If you get weird compilation errors, check
first that the code you are trying to source filter doesn't use extremly esoteric
syntaxes.

Parsing code with PPI takes time. If you are filtering huge amounts of
source code, your program will be slow to compile.

=head1 API

=over 4

=item C<< my $f = new($caller) >>


=item C<< my $f = new($caller,$verbose) >>

TODO

=item C<< $f->insert_top($string) >> or C<< $f->insert_top($coderef) >>

TODO

=item C<< $f->insert_bottom($string) >> or C<< $f->insert_bottom($coderef) >>

TODO

=item C<< $f->insert_before_return($string) >> or C<< $f->insert_before_return($coderef) >>

TODO

=item C<< $f->call_on_return($string,@arg_strings) >> or C<< $f->call_on_return($coderef) >>

TODO

=back

If you use C<$coderef> to generate the inserted code, the subroutine called
will receive only 1 argument: the current instance of Filter::WrapSubs. When
returned while editing a subroutine body, this instance will have the following
attributes set:

=over 4

=item C<< $f->subname >> Return the name of the subroutine currently edited.

=item C<< $f->pdom >> Return the PPI document describing the whole source being parsed.

=item C<< $f->action >> Describes what Filter::WrapSubs will do with the resulting
string. Returns one of the following 4 strings: C<insert_top>, C<insert_bottom>,
C<insert_before_return> or C<call_on_return>.

=back

Since Filter::WrapSubs is a source filter, it even overrides the method C<filter>:

=over 4

=item C<< $f->filter() >> A method called by perl's source filter API. Don't call yourself.

=back

=head1 WHY?

Why not?

More seriously, wrapping subs with anonymous closures at runtime has a number of
drawbacks: the function stack returned by C<confess> contains confusing anonymous
names and the code is harder to follow in a debugger.

=head1 SEE ALSO

See PPI, Filter::Util::Call, Hook::WrapSub.

=head1 BUGS

See PPI. Otherwise, report to the author!

=head1 VERSION

$Id: WrapSubs.pm,v 1.2 2007-09-28 14:22:31 erwan_lemonnier Exp $

=head1 AUTHORS

Erwan Lemonnier C<< <erwan@cpan.org> >>, as part of the Pluto developer group at the Swedish Premium Pension Authority.

=head1 LICENSE

This code was partly developed at the Swedish Premium Pension Authority as
part of the Authority's software development activities. This code is distributed
under the same terms as Perl itself. We encourage you to help us improving
this code by sending feedback and bug reports to the author(s).

This code comes with no warranty. The Swedish Premium Pension Authority and the author(s)
decline any responsibility regarding the possible use of this code or any consequence
of its use.

=cut



